1-3 Journal – The Role of Testing In the Software Development Lifecycle
Hunter Marx
3/7/2025
CS320
Angel Cross

Software development is as fallible as the humans who design it. And despite AI being a new pop culture and pop-tech buzzword, AI is just as fallible as software if designed wrong. This does not change anything and simply adds another layer to it. Software engineers do their jobs under pressure such as looming deadlines, dealing with the complexity of where they lie in the project management hierarchy, which is not usually their own decision, as well as working in a field that is constantly changing in both big ways and small. Humans are fallible and mistakes happen. This is where testing comes into play. 
There are many levels of both vertical and horizontal abstraction. Horizontal abstraction is lines of code, components, systems, applications. Vertical abstraction is GUI, programmer code, machine code, circuits etc. Most people who work on an application do not directly interact with each step of this. One error within a component may be “invisible” or not affect testing of that specific component. It may only cause an effect once applied to an integrated system of components. For this reason, testing at every level of abstraction is vital. An error or mistake can lead to a defect or faulty component, which in turn can lead to failure of a system. Systems can fail from environmental conditions affecting the hardware as well. Once you are at a point of a large system failing and you have no idea where it's coming from, you are pretty much cooked at that point.
If everyone is involved in thorough with all kinds of testing, this can be prevented.
The problem is, trying to draw the line at exhaustive testing is kind of like trying to find the smallest number that is not greater than zero. If we tried to do this with new technologies, we might still be in the last age of human history. We have deadlines for one reason. Deadlines and pressure are part of what causes innovation. Luckily, many programmers and engineers before us have found guidelines and principles so that when we are still students, we can learn how much risk to take and when. When to sacrifice quality at certain levels of abstraction and how much. We can keep them in mind to guide our own work in the future and know when and what to test.
	The most general guiding principle for the planning stage is prioritization and completion criteria. Firstly, for prioritization, at any given moment, if the product needed to be delivered to the market, the testing that had been done should have been the most important testing that needed to be done. The next principal is for there to be a set of “completion criteria” defined for projects. This lays out the amount and areas of software to be tested, as well as the amount of defects that are acceptable in a final delivered project. 
	These play into a model we use called the “Triangle of Resources,” which outlines time, money, and quality that we need to bargain against each other with application features as currency. 
	A requirements document is an important product in the beginning stages of the SDLC. It takes the purpose of a system in question to be tested and is known as a “test basis.” It should specify the “test conditions” as well, or what is to be tested and how, as well as go into specifics of criteria for standard and edge cases of possible outcomes or user actions. Lastly, there should be a stated “test case,” the preconditions for running it, and what to do afterwards, known together as the “test procedure.”
	Testing has many types and contexts but most broadly consists of static testing, which is testing code without executing it, and dynamic testing or testing code during execution. Before testing is done, the setup must be done correctly, and following the actual test, the results must be recorded.
	Tests should be maximized for efficacy, meaning that a test should result in uncovering a mistake. If no mistake is found that test is presumed a waste of time. To ensure efficacy of tests, we used a tried-and-true testing technique based on principles
Testing is a vital part of the software development lifecycle. When developing any application or even a simple program, testing is important. 
When people first learn how to program automatic testing using testing frameworks it is not necessary because manual testing is reasonable. In these initial stages, I learned to always try to “break the program.” Meaning test edge cases of user input, challenge input validation etc. 
I have not personally developed a large-scale application yet, but I understand that when these types of projects are taken on, manual testing is not always feasible. For this reason, we have testing frameworks, which to my understanding are automated testing protocols and rules that provide a guide to testing various components of an application. 
There are the following stages in the SDLC: Planning, defining, designing, building, testing, and deployment. This cycle is a great oversimplification, as the steps are non-sequential and there is a lot of intermixing of steps. This is why we have things like Scrum and Agile, but for our purposes, the relevant thing to keep in mind is the combining of the building and testing phase. 
Throughout the building phase, depending on which component(s) an individual or team is responsible for designing, building, and deploying, testing must be done regularly in a streamlined fashion to ensure smooth integration with the other components. When it comes to us as programmers, I imagine it is helpful to create a black box approach when it comes to testing. Whatever component the project manager assigns us responsibility, we ensure that adequate, thorough, and frequent testing takes place for that component.
Sometimes testing should take place early or later phases, such as the design phrase or the deployment phase. Often instead of the entire application being released at once, there are prototypes or previews in the beginning and beta releases at the ending. This is common with video games. In the case of beta testing, the standard for this is that bugs are more acceptable and expected vs bugs found in a finalized release of the game. 
Without proper testing, disastrous consequences can arise. This includes having to recode large segments of the project and having bugs in the application that a customer finds. It is our job as programmers to find every bug in the application before a customer or consumer finds the bug. With proper testing in place, the SDLC can proceed with optimum efficiency to create the best possible applications.
Testing design encompasses several activities, such as precisely defining test cases based on test conditions as well as set of text cases and optimizing the environment and traceability. Test implementation consists of automating aspects of the testing process, creating test suites and arranging them in the most efficient order. Test execution is the conducting of tests.
In the scenario of agile methodologies, testing for each sprint may look different. And testing might become irrelevant with each iteration of sprints, so a code tester much keep in mind prioritization above all else and test the most important things or thing during each iteration of a sprint, which is a task that requires speed and intuition at the same time. 
In each of the activity groups discussed above, there are corresponding work projects that look different, and code testers keep this in mind as part of the guidelines. Finally, a tester must keep in mind the psychology and ethics of code testing.
There are many guidelines that a code tester must embody and internalize to do their job well. There is no one size fits all formula, and there is no easy answer for what to do in any situation. This is perhaps why a code tester has its coveted position on a team of developers, and said tester must have unique skills, intuition, and knack. It is as much of an art as a science. That said, every student of computer science or technology should grasp the guiding principles of code testing to some degree, as before we work on larger projects, we must direct our own smaller project, and what a better opportunity to practice being a code tester. Who knows, it might be anyone’s future specialization area.






